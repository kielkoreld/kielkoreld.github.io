---
layout: post
title:  "알고리즘 7주차(수정 필요)"
date:   2023-04-15 13:09:00 +0900
categories: jekyll update
---
[강의 노트](https://harmonious-beluga-1f5.notion.site/7-dcdb485c5189427db4dd098a1ddd3093)

오늘은 강의 내용에서 벗어난 이야기도 많고 응용 및 구현의 내용도 적다.\
최근 고민을 많이 해봤는데 공부하고 싶은 것이 많은 것은 좋지만,\
이를 통해서 스트레스를 받는 것은 좋지 않음을 몸소 느꼈다.\
때문에 시험 기간에는 응용 및 추가 조사에 대한 미련을 잠시 놓기로 했다.\
물론 아예 놓은 것은 아니다. 시험 기간만 지나면 다시 다룰 계획이다.\
글의 제목에 *(수정 필요)*가 추가된 것도 그 이유이다. 

우선 내용을 간단히 정리하고 누락된 부분이 무엇인지 설명한 뒤에 여담을 풀고자 한다.

### 허프만 압축
허프만 압축에 대해 배우면서 **그리디 알고리즘**에 대한 수업이 끝났다.\
허프만 압축이란 빈도수가 많은 문자에 적은 비트를 할당하는 방식이다.\
사용하는 자료 구조는 *우선순위 큐*, 즉 *히프 구조*이다.\
히프라는 단어가 친숙하지 않다면 *완전 이진 트리*라고 생각하면 편하다.\
단, 완전 이진 트리보다 조금 더 정렬에 관대한 편이다.\
예를 들어 완전 이진 트리의 왼쪽 자식은 항상 부모보다 작지만,\
히프 구조는 그렇지 않아도 무방하다. 즉, 느슨한 정렬을 허가한다.

우선순위 큐에 삽입을 할 때에는 가장 아래, 즉 이파리에 삽입한다.\
그 후에 부모 노드와 비교하여 적절하게 값을 교환한다.\
반대로 삭제를 할 때에는 이파리와 루트의 위치를 바꾸고\
이파리를 제거한 다음에 루트와 자식 노드의 값을 비교 및 교환한다.

이런 구조의 우선순위 큐에서 빈도수가 작은 노드를 2개씩 꺼낸다.\
노드를 새롭게 1개 만들어 이 둘을 자식노드로 넣고\
빈도수를 두 노드의 합으로 설정한 뒤에 다시 우선순위 큐에 삽입한다.\
이를 반복하여 히프 구조를 만든다.

이렇게 제작한 히프 구조에서 왼쪽 자식으로 갈 때에는 0,\
오른쪽 자식으로 갈 때에는 1의 비트를 할당한다.\
그 결과 각 문자에게 빈도수에 따른 비트를 할당할 수 있다.

---

## 동적 할당 알고리즘
동적 할당 알고리즘은 DP라고 부르며 분할 정복 알고리즘과 유사한 구조이다.\
대표적인 차이점은 분할한 부분문제간의 의존성이다.\
분할 정복 알고리즘은 부분문제의 해가 하나의 상위 부분문제에 영향을 주는 반면,
동적 할당 알고리즘은 부분문제의 해가 여러 상위 부분문제에 영향을 준다.\
즉, 부분문제의 해가 여러 번 호출되기 때문에 임시로 저장을 하기도 한다.

### 연속 행렬의 곱셈
연속적인 행렬들의 곱셈의 최소 연산 회수를 찾는 연산에서 **DP 알고리즘**이 쓰인다.\
예를 들어, A×B×C×D는 A×(B×C×D), (A×B)×(C×D), (A×B×C)×D로 3개의 부분문제가 있다.\
각각의 부분문제는 또다시 다른 부분문제의 해와 의존성이 높다.

이를 구현하기 위해서는 *대칭성분이 0인 상삼각행렬*을 이용한다.\
연산은 *우하향인 대각선이 점점 우측*으로 이동하는 모양이고\
그 안에서는 *행과 열의 합이 같은 모든 상황*을 고려한다.\
글로는 이해가 어려우니 사진을 첨부하겠다. 사진을 보면 이해가 쉬울 것이다.\
![연산 순서에 대한 사진](https://raw.githubusercontent.com/kielkoreld/kielkoreld.github.io/main/_posts/photo/matrix1.jpg)
![부분문제에 대한 사진](https://raw.githubusercontent.com/kielkoreld/kielkoreld.github.io/main/_posts/photo/matrix2.jpg)

### 배낭 문제
이전에 **그리디 알고리즘**으로 *부분 배낭 문제*를 풀었다.\
이번에는 물건을 나눌 수 없다는 조건이 추가되면서 조건이 많이 추가됐다.\
우선 아무것도 넣지 않은 경우의 가치를 0으로 초기화하고\
배낭의 크기를 분할하여 다루기 때문에 배낭의 크기가 0인 것도 초기화한다.\
그리고 물건을 담을 수 있는가에 대한 여부를 파악한다.\
만약 *물건을 담을 수 없다면*, 담을 수 있던 상황을 그대로 가져온다.\
이는 바로 위의 행에 존재한다.\
만약 *물건을 담을 수 있다면*, 어느 것이 더 좋은지 비교해야 한다.\
우선 *넣지 않는 상황*, 즉 바로 위의 행에 대한 정보를 가져온다.\
그리고 *넣는 상황*과 비교하여 더 가치가 높은 것을 저장한다.\
*넣는 상황*에 대한 연산은 우선 넣을 공간을 만들어야 한다.\
이에 대한 정보는 위의 행에서 물건의 무게만큼 좌측으로 이동하여 찾는다.\
넣을 공간을 만든 상황에서의 가치와 넣을 물건의 가치를 더하여\
*넣는 상황*에서의 가치를 구한다. 그리고 이를 비교하여 더 좋은 것을 저장한다.\
![배낭 문제에 대한 사진](https://raw.githubusercontent.com/kielkoreld/kielkoreld.github.io/main/_posts/photo/backpack.jpg)


여기까지 수업 내용을 요약했다.\
이후로는 **구현하지 않은 것**을 정리하기 위한 글이다.

우선 구현하지 않은 것은 *허프만 코드* 부분이다.\
히프 구조까지는 제작을 끝냈지만,\
허프만 코드를 부여하여 *부호화 및 복호화*를 하는 부분은 구현하지 않았다.\
또한, *연속 행렬 곱셈의 연산 회수*를 계산하는 것도 구현하지 않았다.\
마지막으로 *배낭 문제*에서 최종적으로 어떤 물건을 담았고\
총 가치가 어떻게 되는지 조금 더 보기 좋게 정리하는 부분을 구현해야 한다.\
이를 구현하지 않은 것은 최근에 이런 공부들이 과제처럼 느껴졌기 때문이다.\
지금도 당장 구현해보고 싶지만, 지금 당장 내가 해결할 과제와 시험 준비가 우선이다.\
때문에 아쉽지만, 방학이든 이후의 쉬는 시간에 조금씩 구현을 해봐야 할 것 같다.